---
layout: default
title: 进程管理
nav_order: 第2-3章
---

# 第2-3章 进程管理

## 易错点整理

- 进程实体是由进程控制块、程序段和数据段组成的。
- 产生死锁的原因
  - 对独占资源的共享 *资源竞争*
  - 并发进程的同步关系不当 *进程推进关系不当*
- 按照作业到达的先后次序调度作业，排队等待时间最长的作业先执行，这种调度算法称为先来先服务调度算法。
  - 先来先服务实际上是长作业优先调度算法。
- 进程调度的方式
  - 非抢占式调度
  - 抢占式调度

## 额外补充

- 对换与置换
  - 两者都是实现内存和外存的信息交换
  - 又是需要将内存中的信息换出到外存，又是需要将外存中的信息换入到内存
  - 交换是指以进程为基本单位的信息交换，而置换通常是指以进程的一部分为单位的信息交换
  - 对换与置换都是扩充内存容量的支持技术

## 复习提纲

1. 程序顺序执行的特点

    ```markdown
    1. 串行性
    2. 封闭性
    3. 可再现性
    ```

2. 何谓进程，进程由哪些部分组成？试述进程的四大特性（动态性、独立性、并发性、结构性）及进程和程序的区别。

    ```markdown
    1. 进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程，它是系统进行资源分配和调度的一个独立单位。
    2. 进程由程序、数据和进程控制块PCB三部分组成。
    3. 进程的四大特性：
        1. 动态性：进程是程序的一次执行过程，是一个时间段的集合，是动态产生、变化和消亡的。
        2. 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的一个独立单位。
        3. 并发性：任何进程都可以同其他进程一起并发执行。
        4. 结构性：进程由程序、数据和进程控制块三部分组成。系统为每个进程均建立一个PCB。
    4. 进程和程序的区别：
        1. 进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程，它是系统进行资源分配和调度的一个独立单位。
        2. 程序是指令和数据的有序集合，它是一个被动的概念，是一个静态的实体。
    ```

3. 进程控制块的作用是什么?它主要包括哪几部分内容?

    ```markdown
    1. 进程控制块的作用：
        1. 进程控制块是进程存在的唯一标志，它是系统中最重要的数据结构之一。
        2. 进程控制块是进程的“映像”，它反映了进程的动态变化过程。
    2. 进程控制块主要包括以下部分内容：
        1. `进程标识符`：唯一标识一个进程，通常是一个正整数。
        2. `进程的状态、调度、存储器管理信息`：是调度进程所必需的信息，包括进程状态、优先级、程序在主存地址、在外存的地址等。
        3. `进程使用的资源信息`：分配给进程的I/O设备、正在打开的文件等。
        4. `CPU现场保护区`：保护进程运行的现场信息，包括程序计数器、程序状态字、通用寄存器、浮点寄存器、堆栈指针等。
        5. `记账信息`：进程使用CPU的时间、实际用时、账户号等。
        6. `进程之间的家族关系`：进程的父进程、子进程、兄弟进程等。
        7. `进程的链接指针`：链接相同状态的进程，如就绪队列、等待队列等。
    ```

4. 进程的基本状态，试举出使进程状态发生变化的事件并描绘它的状态转换图。

    ```markdown
    1. 进程的基本状态：
        1. `就绪态`：进程已获得除处理机以外的一切所需资源，一旦获得处理机即可立即执行。
        2. `运行态`：进程已获得处理机，其程序正在处理机上执行。
        3. `阻塞态`：进程在等待某一事件发生而暂时停止运行，如等待I/O完成、申请缓冲区失败等。
    2. 使进程状态发生变化的事件：
        1. 进程创建：创建一个进程，将其加入到就绪队列中。
        2. 进程调度：从就绪队列中选取一个进程，将其调度到处理机上运行。
        3. 进程阻塞：进程等待某一事件发生，如等待I/O完成、申请缓冲区失败等。
        4. 进程唤醒：进程等待的事件发生，如I/O完成、缓冲区可用等。
        5. 进程终止：进程执行完成或发生错误，如除数为0、内存溢出等。
    3. 状态转换图：
    ```

    ```mermaid
    graph LR
    A[创建态] --> B[就绪态]
    B --进程调度--> C[执行态]
    C --被抢先--> B
    C --进程完成--> E[终止态]
    C --等待事件--> D[阻塞态]
    D --事件完成--> B
    ```



5. 什么是原语?什么是进程控制？

    ```markdown
    1. 原语：是不可分割、不能被中断的操作，要么全做，要么全不做。
    2. 进程控制：是指操作系统对进程的创建、撤销、阻塞、唤醒、切换、调度等操作。
    ```


6. 进程调度的功能、方式、时机、算法。作业调度，交换调度。作业的周转时间和作业的带权周转时间?

    ```markdown
    0. 进程调度：低级调度。是指从就绪队列中选取一个进程，将其调度到处理机上运行。
    1. 进程调度的功能：
        1. 记录系统中各进程的执行状况。
        2. 选择就绪进程占有CPU。
        3. 进行进程上下文的切换。
    2. 进程调度的方式：
        1. 非抢占式调度：进程运行时不允许被抢占。
        2. 抢占式调度：进程运行时允许被抢占。
    3. 进程调度的时机：
        1. 进程完成或者错误终止时。
        2. 提出I/O请求，等待I/O完成时。
        3. 在分时系统中，按照时间片轮转，时间片用完时。
        4. 优先级调度，更高优先级的进程到达时。
        5. 进程执行了某种原语操作，如阻塞原语和唤醒原语，都可能引起进程调度。
    4. 进程调度的算法：
        1. 先来先服务调度算法（FCFS）
        2. 短作业优先调度算法（SJF）
        3. 响应比高者优先调度算法（HRN）
        4. 优先级调度算法
        5. 时间片轮转调度算法（RR）
        6. 多级反馈队列调度算法
    5. 作业调度：高级调度。多道批处理系统。多个用户作业以成批的形式提交到外存，形成后备作业队列。被作业调度选中进内存，就处于运行态。
    6. 交换调度：中级调度。将主存就绪或主存阻塞队列中暂不具备运行条件的进程换出到外存；或将外存就绪队列中的进程换入到主存，将其加入到就绪队列中。交换调度可以控制进程对主存的使用。
    7. 作业的周转时间：作业从提交到完成所经历的时间。
    8. 作业的带权周转时间：周转时间与估计运行时间的长度之比。
    ```


7. 线程的定义，线程与进程的比较。系统对线程的支持（用户级线程、核心级线程、两级组合）。

    ```markdown
    1. 线程：是进程中的一个可执行实体，是处理机调度的基本单位。
    2. 线程与进程的比较：
        1. 拥有的资源：
            1. 进程拥有一个独立的地址空间，用来存放若干的数据段和代码段，若干打开文件以及至少一个线程。
            2. 而进程中的多个线程共享该进程的所有资源，自己只拥有很少一部分资源。
        2. 调度：
            1. 进程调度需要保存和恢复进程的上下文，开销较大。
            2. 同一进程内的线程切换只需要将一小部分资源变换即可，效率高。同一进程内的线程切换比进程切换快得多，而不同进程间的线程切换比较慢。
        3. 并发性：
            - 引入线程的操作系统，不仅进程之间可以并发执行，而且同一进程内的多个线程之间也可以并发执行，不同进程间的线程之间也可以并发执行。
        4. 安全性：
            - 同一进程的多线程共享进程的资源，一个进程可以改变另一个进程的数据，共享数据方便，多进程实现，安全性好。
        5. 系统开销：
            - 系统为每个进程分配一个PCB，而为每个线程分配一个TCB，线程的开销比进程的开销小。
    3. 系统对线程的支持：   
        1. 用户级线程：
            - 有关线程的管理工作由用户程序完成，内核对线程一无所知。自己设计线程调度算法。
            - 内核以进程为单位进行调度；
            - 一个线程阻塞，整个进程阻塞，其它的线程也不能运行。
            - 多对一模型：多个用户级线程映射到一个内核级线程。
            - POSIX Pthreads
        2. 核心级线程：
            - 有关线程的管理工作都由内核来完成。应用程序通过系统调用来创建或者撤销线程。
            - 一个线程的阻塞不影响其它线程的运行。
            - 一对一模型：每个用户级线程映射到一个内核级线程。
            - Windows, Linux, 多处理机系统
        3. 两级组合：
            - 既支持用户级线程也支持核心集线程。
            - 多对多模型：多个用户级线程映射到多个内核级线程。
            - 当内核了解道一个线程阻塞之后，通知运行时系统重新调度其它线程。
            - Solaris
    ```

8. 并发执行的进程在系统中通常表现为几种关系?各是在什么情况下发生的?

    ```markdown
    > 通常表现为互斥和同步的关系
    1. 对资源的共享引起的互斥关系：进程之前本来是相互独立的，但由于共享资源而产生了关系。间接制约关系，互斥关系。
    2. 协作完成同一个任务而产生的同步关系：一组协作进程在某些同步点上需要相互等待发送信息后才能继续进行。直接制约关系，同步关系。
    3. 进程的前序关系：由于进程之间的同步和互斥关系，使得进程之间形成了一种前序关系，这些关系决定了各个进程创建和终止的时间。
    ```

9.  什么叫临界资源?什么叫临界区?对临界区的使用应符合的四个准则（互斥使用、让权等待、有空让进、有限等待）。

    ```markdown
    1. 临界资源：一次仅允许一个进程使用的系统中共享资源。
    2. 临界区(critical section)：就是并发进程访问临界资源那段必须互斥执行的程序代码。
    3. 临界区的使用应符合的四个准则：
        1. 互斥使用（忙则等待）：不能同时有两个进程在临界区执行。
        2. 让权等待：等待进入临界区的进程，应当释放处理机后阻塞等待。
        3. 有空让进（空闲让进）：在临界区外运行的进程不可阻止其他进程进入临界区。
        4. 有限等待：不应使要进入临界区的进程无限期等大地在临界区之外。
    ```

10. 解决进程之间互斥的办法：开、关中断，加锁、开锁（又叫测试与设置，通常由一条机器指令完成），软件方法，信号量与P、V操作。

    ```markdown
    1. 硬件实现方法：
        1. 中断屏蔽：进入临界区之前，关中断；退出临界区之后，开中断。
        2. 硬件指令：TestAndSet指令，原子操作。为每个临界资源设置一个锁标志，进入临界区之前，先检查锁标志，若为0，则将其置为1，表示进入临界区，否则等待。
    2. 软件实现方法：
        - Peterson算法：两个进程P0和P1，各自设置一个标志位flag，用来表示自己是否进入临界区，另一个标志位turn，用来表示对方是否进入临界区。进入临界区之前，先将自己的flag置为1，然后将turn置为对方的标志位，然后检查对方的flag是否为1、turn是否为对方标志位，若为1，则等待，否则进入临界区。退出临界区之后，将flag置为0。
    3. 信号量与P、V操作：
        1. 信号量：是一个整型变量，只允许对它进行两种原语一级的操作：P操作和V操作。
        2. P操作：是对信号量S的值减1，即S=S-1。
        3. V操作：是对信号量S的值加1，即S=S+1。
    ```

11. 若信号量S表示某一类资源，则对S执行P、V操作的直观含意是什么? 当进程对信号量S执行P、V操作时，S的值发生变化，当S>0、S=0、和S<0时，其物理意义是什么?

    ```markdown
    1. 若信号量S表示某一类资源，则对S执行P、V操作的直观含意是：
        1. P操作：申请资源，若S>0，则S=S-1，否则等待。
        2. V操作：释放资源，若S>0，则S=S+1，否则唤醒等待该资源的进程。
    2. 当进程对信号量S执行P、V操作时，S的值发生变化，当S>0、S=0、和S<0时，其物理意义是:
        1. S>0：表示可用资源的数目。
        2. S=0：表示无可用资源。
        3. S<0：绝对值表示等待资源的进程数目。
    ```

12. 在用P/V操作实现进程通信时，应根据什么原则对信号量赋初值？

    ```markdown
    1. 信号量赋初值的原则：
        1. 互斥信号量：初值为1。
        2. 同步信号量：初值为0。
        3. 计数信号量：初值为资源的数目。
    ```

13. 经典的IPC问题。

    1. 生产者-消费者问题

        ```c
        semaphore mutex = 1; // 互斥信号量
        semaphore empty = n; // 空缓冲区信号量
        semaphore full = 0; // 满缓冲区信号量
        
        producer() {
            while (true) {
                produce an item in nextp;
                P(empty);
                P(mutex);
                add nextp to buffer;
                V(mutex);
                V(full);
            }
        }

        consumer() {
            while (true) {
                P(full);
                P(mutex);
                remove an item from buffer;
                V(mutex);
                V(empty);
                consume the item;
            }
        }
        ```

    2. 读者-写者问题

        ```c
        semaphore mutex = 1; // 互斥信号量更新readcount
        semaphore wrt = 1; // 读者写者互斥信号量
        int readcount = 0; // 读者计数器

        writer() {
            while (true) {
                P(wrt);
                writing;
                V(wrt);
            }
        }

        reader() {
            while (true) {
                P(mutex);
                readcount++;
                if (readcount == 1) P(wrt);
                V(mutex);
                reading;
                P(mutex);
                readcount--;
                if (readcount == 0) V(wrt);
                V(mutex);
            }
        }
        ```

        上面这种解法会导致写者饥饿，因为读者可能一直读，导致写者一直等待。我们可以通过引入一个互斥信号量来解决这个问题，从而变成读写公平（或者叫写者优先，相对而言）。

        ```c
        semaphore mutex = 1; // 互斥信号量更新readcount
        semaphore wrt = 1; // 读者写者互斥信号量
        semaphore w = 1; // 读写公平信号量
        int readcount = 0; // 读者计数器

        writer() {
            while (true) {
                P(w);   // 新增
                P(wrt);
                writing;
                V(wrt);
                V(w);   // 新增
            }
        }

        reader() {
            while (true) {
                P(w);   // 新增
                P(mutex);
                readcount++;
                if (readcount == 1) P(wrt);
                V(mutex);
                V(w);   // 新增
                reading;
                P(mutex);
                readcount--;
                if (readcount == 0) V(wrt);
                V(mutex);
            }
        }
        ```

    3. 哲学家就餐问题

        ```c
        semaphore chopstick[5] = {1, 1, 1, 1, 1}; // 互斥信号量

        philosopher(int i) {
            while (true) {
                think();
                P(chopstick[i]);
                P(chopstick[(i+1)%5]);
                eat();
                V(chopstick[i]);
                V(chopstick[(i+1)%5]);
            }
        }
        ```

        但上面这样的解法会导致死锁，因为每个哲学家都先拿起自己左边的筷子，然后等待右边的筷子，这样就会导致每个哲学家都在等待，从而导致死锁。我们可以通过引入一个服务生（互斥信号量）来解决这个问题。

        ```c
        semaphore chopstick[5] = {1, 1, 1, 1, 1}; // 互斥信号量
        semaphore mutex = 1; // 互斥信号量

        philosopher(int i) {
            while (true) {
                think();
                P(mutex);
                P(chopstick[i]);
                P(chopstick[(i+1)%5]);
                V(mutex);
                eat();
                V(chopstick[i]);
                V(chopstick[(i+1)%5]);
            }
        }
        ```

    4. 吸烟者问题

        ```c
        semaphore agent = 1; // 互斥信号量
        semaphore tobacco_paper = 0; // 烟草和纸
        semaphore tobacco_match = 0; // 烟草和火柴
        semaphore paper_match = 0; // 纸和火柴

        agent() {
            while (true) {
                P(agent);
                int r = rand() % 3;
                switch (r) {
                    case 0:
                        V(tobacco_paper);
                        break;
                    case 1:
                        V(tobacco_match);
                        break;
                    case 2:
                        V(paper_match);
                        break;
                }
            }
        }

        smoker_tobacco_paper() {
            while (true) {
                P(tobacco_paper);
                make_cigarette();
                smoke();
                V(agent);
            }
        }

        smoker_tobacco_match() {
            while (true) {
                P(tobacco_match);
                make_cigarette();
                smoke();
                V(agent);
            }
        }

        smoker_paper_match() {
            while (true) {
                P(paper_match);
                make_cigarette();
                smoke();
                V(agent);
            }
        }
        
        ```

    5. 理发师问题

        ```c
        semaphore count = 0; // customer count
        semaphore empty = n; // n empty chairs
        
        customer() {
            while (true){
                P(empty);
                V(count);
                wait;
            }
        }
        
        barber() {
            while (true){
                P(count);
                cut hair;
                V(empty);
            }
        }
        
        ```


14. 进程高级通信有哪些实现机制？

    ```markdown
    1. 消息缓冲：
        1. 系统设置一个消息缓冲池，其中每个缓冲区可以存放一个消息；
        2. 每当进程发送消息时，向系统申请一个缓冲区，然后将缓冲区链接到接收进程的消息队列上；
        3. 消息队列放在接受进程的PCB中；
        4. 属于直接通信的方式；
    2. 信箱：
        1. 发送进程将消息发送到中间媒介信箱中，接收进程从中取得消息；
        2. 属于间接通信的方式；
        3. 发送原语`send(A,Msg)`和接收原语`receive(A,Msg)`
    3. 管道：
        1. 生产者消费者的模式通信，用于连接一个读进程和一个写进程的共享文件，又称pipe文件。OS强制实施互斥。
        2. 通过操作系统管理的环形缓冲区，先进先出；
        3. 分为命令方式和程序方式的管道通信；
    4. 共享主存区：
        1. 各个进程为了相互交换大量数据申请一块共享存储区，并将该共享存储区映射到各自的地址空间，通过读写共享存储区中的数据来实现通信。
    ```

15. 死锁产生的必要条件及解决死锁的方法

    ```markdown
    1. 死锁产生的必要条件：
        1. 互斥条件
            - 独占性的资源
        2. 请求并保持条件
            - 因请求资源而阻塞时对已经获得的资源保持不释放
        3. 不剥夺条件
            - 已分配给进程的资源不能被剥夺，只能由进程自己释放；
        4. 循环等待条件
            - 存在一个进程循环链，链中的每个进程都在等待链中的下一个进程所占用的资源释放
    2. 解决死锁的方法：
        ~~1. 鸵鸟算法：忽略死锁~~
        2. 死锁预防：破坏死锁的四个必要条件之一
            1. 破坏互斥条件：基本不行；
            2. 破坏请求并保持：预先静态分配的方法，一次获得全部所需的资源；
            3. 破坏不剥夺：让进程暂时释放，有可能因为过于谦让导致饥饿；
            4. 破坏循环等待：顺序资源分配法；
        3. 死锁避免：银行家算法
        4. 死锁的检测和恢复：允许死锁发发生，通过检测机构，（资源分配图和死锁定理），及时检测死锁的发生，采取适当的措施处理：
            - 资源剥夺法
            - 撤销进程法
            - 进程回退法
    ```

16. 理解银行家算法的实质。能够利用银行家算法避免死锁。

    看ppt或者王道的具体例子理解的更快；

    下面程序只是笔者想出来的银行家算法的python版本的一个例子，实际上如果本身就死锁了那么上面程序肯定也会陷入死循环中，建议还是直接做题理解快。

$$
\text{Max-Demand} = 
\begin{bmatrix}
  4&  1&  1& 1 \\
  0&  2&  1& 2\\
  4&  2&  1& 0\\
  1&  1&  1& 1\\
  2&  1&  1& 0
\end{bmatrix} ,\quad
\text{Assigned} = 
\begin{bmatrix}
  3&  0&  1& 1 \\
  0&  1&  0& 0\\
  1&  1&  1& 0\\
  1&  1&  0& 1\\
  0&  0&  0& 0
\end{bmatrix} \\
$$

$$
\text{Need} = \text{Max-Demand} - \text{Assigned}
$$

```python
E = (6 3 4 2)
A = E - sum(assigned, dim = 0) = (1 0 2 0)
while sum(need): 
    for row in range(len(need)):
        # 找到小于A的一行
        is_le = true
        for col in range(len(need[row])):
            if need[row][col] > A[col]:
                is_le = false
        
        # 如果符合安全性检测 则删掉该行，更新A
        # 否则去找下一个小于的
        if is_le and check_safe():
            need[row] = (0 0 0 0)
            A += assigned[row]
```

