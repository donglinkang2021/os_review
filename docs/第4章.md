---
layout: default
title: 存储器管理
nav_order: 第4章
---

# 第4章 存储器管理

## 易错点整理

- 现代操作系统可以做到在读/写文件之前无需先打开文件，以加快对文件的操作 【❌】
  - 肯定要先打开文件才能读写文件

## 复习提纲


1. 存储器管理的功能。名字空间、地址空间、存储空间、逻辑地址、物理地址。

    ```markdown
    1. 存储器管理的功能：
        1. 存储器分配
            - 解决多道程序或多进程共享主存的问题
        2. 地址转换和重定位
            - 研究各种地址变换方法集相应的地址变换机构
            - 逻辑地址-->物理地址
        3. 存储器保护
            - 复制故障程序破坏OS和其它信息
        4. 存储器扩充
            - 采用多级存储技术实现虚拟存储器及所用的各种管理算法
        5. 存储器共享
            - 并发执行的进程如何共享主存中的程序和数据
    2. 符号名字空间
        - 源程序中的各种符号名的集合所限定的空间。如源程序中的数据和子程序通常是用符号名进行访问的。
    3. 逻辑地址空间
        - 经编译链接后的目标代码所限定的空间。用地址吗替换符号地址。
    4. 物理地址空间
        - 主存中的空间。用物理地址替换逻辑地址。
    > 物理地址也叫绝对地址、实地址；逻辑地址也叫相对地址、虚地址。
    ```

2. 什么是地址重定位?分为哪两种?各是依据什么和什么时候实现的?试比较它们的优缺点。

    ```markdown
    1. 地址重定位
        - 把程序地址空间的逻辑地址转换为存储空间的物理地址。地址映射或地址变换；
    2. 分为静态重定位和动态重定位
        1. 静态重定位
            1. 进程执行前由装入程序完成
            2. 特点：
                - 无硬件变换结构；
                - 为每个程序分配一个连续的存储区；
                - 在程序执行期间不能移动，主存利用率低；
                - 难以做到程序和数据的共享；
                - 适用于单道批处理系统；
        2. 动态重定位
            1. 装入程序把程序和数据原样装入到已分配的存储区中。程序运行时，把该存储区的起始地址送入重定位寄存去，由硬件实现地址变换。
            2. 特点：
                - 主存利用充分且可移动用户程序
                    - 移动后只需修改重定位寄存器
                - 程序不必占有连续的存储区
                - 便于多用户共享存储器中的同一程序和数据
                - 适用于多道批处理系统、分时系统；
    ```

3. 内存划分为两大部分：**用户空间**和**操作系统空间**。存储器管理是针对**用户空间**进行管理的。

4. 存储保护的目的是什么?对各种存储管理方案实现存储保护时，硬件和软件各需做什么工作?

    ```markdown
    1. 目的：赋值地址越界
        - 进程运行时产生的所有存储器访问地址都要进行检查，确保只访问为该进程分配的存储区域；
    2. 各种存储方案：
        1. 固定分区
            1. 静态重定位，进程运行时使用主存物理地址；
            2. 设置上下界寄存器，检查地址是否越界，实现存储器保护；
        2. 可变分区
            1. 动态重定位，进程运行时CPU给出的时程序的逻辑地址；
            2. 基址+限长寄存器。
        3. 页式
            1. 可在页表中增加对该页的操作方式位，表示时可读写或只读或只执行；
            2. 使用越界中断的判断机构判断是否越界；
        4. 段式
            1. 第一级保护：控制寄存器的段表长度>段号
            2. 第二级保护：段表的段长>段内地址
            3. 对段的信息进行保护：在段表中增加相应的操作方式字段，对相应的段规定读、写、执行操作权限
    ```

5. 试述可变式分区管理空闲区的方法及存储区的保护方式。覆盖与交换有什么特点？*考过*

    ```markdown
    1. 可变式分区管理空闲区的方法：
        - 分区说明表
        - 空闲区链表
    2. 存储区的保护方式：
        1. 动态重定位，进程运行时CPU给出的时程序的逻辑地址；
        2. 使用基址+限长寄存器完成存储保护
    3. 覆盖与交换的特点：
        1. 覆盖：
            - 打破了必须将一个进程的全部信息装入主存才能运行的限制
            - 在逻辑上扩充了主存
            - 小主存可运行大进程
        2. 交换：
            - 系统根据需要把主存中暂不运行的进程的部分或全部信息移到外存，而把外存中的进程移到主存并投入运行；
            - 解决了主存容量不够大的问题；
            - 保证分时用户的合理响应时间；
    ```

6. 页表的作用是什么?简述页式管理的地址变换过程。能利用页表实现逻辑地址转换成物理地址。管理内存的数据结构有哪些？

    ```markdown
    1. 页表：
        1. 系统为每个进程建立一张页面映像表，记录逻辑也与主存块之间的映射关系。
        2. 页表一般放在内存中；
    2. 页式管理的地址变换过程：
        1. 把该进程的页表始址和页表长度放入CPU的控制寄存器中；
        2. 将程序计数器内容的页号部分与控制寄存器中的页表长度相比较，若页号大于页表长度，则产生越界中断；
        3. 若页号小于页表长度，将持续计数器中的页号与控制寄存中的页表始址相加，得到该访问操作所在页号在页表中的入口地址。这里的加时根据页表项占用的字节数决定的；
        4. 用该地址访问页表，获得该页对应的主存块号；
        5. 将页内地址与主存块号相连，得到物理地址；
    3. 管理内存的数据结构：
        1. 存储分块表
        2. 位示图
    ```

7. 什么是页式存储器的内零头?它与页的大小有什么关系?可变式分区管理产生什么样的零头（碎片）？

    ```markdown
    1. 页式存储器的内零头：
        - 内部碎片
        - 页式存储器的内零头是指一个页中未被程序使用的部分。
    2. 页式存储器的内零头与页的大小有关，
        - 页的大小越大，内部碎片越大。
    3. 可变式分区管理产生的零头：
        - 产生外部碎片
    ```

8. 段式存储器管理与页式管理的主要区别是什么?

    ```markdown
    段式与页式管理的比较：
    1. 段是由用户划分的；页是为了方便管理由硬件划分的，对用户是透明的；
    2. 页的大小固定；段的大小不固定；
    3. 段式用二维地址空间（必须给出段号和段内地址，因为每个段长度不一样）；页式用一维地址空间（给出地址可以算出页号和页内地址）；
    4. 段允许动态扩充，便于存储保护和信息共享；
    5. 段产生外部碎片（主存碎片），但页没有外部碎片；段没有内部碎片，但页有内部碎片；
    6. 段式管理便于实现**动态链接**，页式管理只能进行**静态链接**；
    7.段与页一样，实现地址变换开销大，表格多；
    ```

9. 什么是虚拟存储器。虚拟存储器的容量能大于主存容量加辅存容量之和吗?

    ```markdown
    1. 虚拟存储器
        - 是系统为了满足应用对存储器容量的巨大需求而构造的一个非常大的地址空间；
    2. 可以大于主存容量加辅存容量之和
        - 虚拟存储器的容量由虚拟地址的逻辑结构所决定的，与主存容量和辅存容量无关；
    ```

10. 实现请求页式管理，需要对页表进行修改，一般要增加状态位、修改位、访问位。试说明它们的作用。

    ```markdown
    1. 状态位
        - 也叫有效位，用于标识该页是否在主存中；
        - 为1表示在主存中，完成正常的地址变换；
        - 为0表示不在主存中，硬件产生缺页中断，由操作系统进行缺页处理；
    2. 修改位
        - 用于标识该页是否被修改过；
        - 为1表示被修改过，需要将该页写回辅存；
        - 为0表示未被修改过；
    3. 访问位
        - 用于标识该页是否被访问过；
        - 为1表示被访问过；
    ```


11. 产生缺页中断时，系统应做哪些工作? 

    ```markdown
    1. 根据当前指令的逻辑地址查询页表的状态位，若为0，则产生缺页中断；
    2. 操作系统处理缺页中断，在内存中寻找一个空闲的页框；
    3. 若**有**空闲页框，则将该页框分配给当前进程，修改页表，将状态位置1；
    4. 若**无**空闲页框，则根据页面置换算法选择一个牺牲页框，将其内容写回辅存，修改页表，将状态位置0；调入所需的页，修改页表，将状态位置1；之后还要修改相应的页表和内存分配表；
    5. 恢复现场，重新执行被中断的指令；   
    ```

12. 会利用FIFO、LRU、OPT以及时钟页面置换算法描述页面置换过程，计算产生的缺页率。Belady异常。

    ```markdown
    > 这里主要还是看自己得多做题才行
    1. **FIFO**
        - 选择最先进入内存的页予以淘汰；
        - 缺点：可能会产生**Belady**异常；
    2. **LRU**
        - 选择过去最久未访问的页予以淘汰；
        - 缺点：需要记录每个页的使用时间（stamp），需要一个时间戳，时间戳的更新需要时间；
    3. **OPT**
        - 选择未来最久未访问的页予以淘汰；
        - 缺点：需要预测未来的访问情况，不可能实现；
    4. **时钟页面置换算法**
        - 二次机会算法，循环链表；
        - 从当前指针位置开始，若该页被访问过，则将访问位置0，指针指向下一个页，直到找到一个访问位置为0的页，将其淘汰；
    ```

13. 什么是程序的局部性原理？什么叫系统抖动?工作集模型如何防止系统抖动?

    ```markdown
    1. 局部性原理：
        1. 时间局部性
            - 持续中往往含有许多循环，在一段时间内会重复执行该部分。
        2. 空间局部性
            - 持续中有许多分支，在一次执行中，只有满足条件的代码运行，不满足条件的代码不运行。即使顺序执行持续，程序的弟子域在短时间内页变化不大；
        3. 在进程运行过程中，用到哪部分程序或数据再由系统自动装入；
    2. 系统抖动
        - 刚被淘汰的页面马上又要用，因而又把它调入，调入不久在被淘汰，又要调入，如此频繁地调入调出，降低了系统的处理效率；
    3. 工作集模型
        - 在一段时间内，进程集中在一组子程序或者循环中执行，导致所有的存储器访问局限于进程地址空间的一个固定的子集；
        - 工作集模型的原理是，让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。
            - 落在工作集内的页面需要调入驻留集中，而落在工作集外的页面可以从驻留集（分配给进程的物理块数）中换出；
            - 若还有空闲物理块，则可再调一个进程到内存中；
            - 若所有进程的工作集之和超过了可用物理块总数，则操作系统会暂停一个进程，将其页面调出并将物理块分配给其它进程，防止出现抖动现象；
    ```


14. 多级页表的概念，多级页表中页表建立的时机。写时复制技术的概念。 *考过*

    ```markdown
    1. 多级页表
        - 页表不再占用连续的主存空间
        - 且页表再使用时才被装入
        - 从而大大节约了主存空间
    2. 多级页表中页表建立的时机
        - 页表的建立不再是在进程装入主存时
        - 而是推迟到要访问页时，才为包含该页的页表分配空间和建立页表项
    3. 写时复制技术
        - 若没有进程向共享主存页写时，两个进程就共享之；
        - 若有进程要写某页，系统就把此页复制到主存的另一个页框中，并更新该进程的页表，使之指向此复制的页框，且设置该页为可读/写；
    ```


15. 页的共享问题。需要一个专门数据结构来记录进程间共享页。

    ```markdown
    - 页的共享可以避免在主存中同时又多个相同的页的副本。节约主存。
    - 通常，只读页（如程序文本）可以共享，可读/写的数据页不可共享；
    - 需要一个专门的数据机构来记录共享页。把共享页锁在内存，且在页表中增加引用计数项，仅当其引用计数为0时，才允许调出或释放盘空间。
    ```